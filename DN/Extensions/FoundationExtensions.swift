//
//  FoundationExtensions.swift
//  Joy
//
//  Created by Apple on 16/4/13.
//  Copyright © 2016年 AppES. All rights reserved.
//

import Foundation
import UIKit
import SwiftDate

extension Array {
	/// : Returns a random element from the array.
	public func random() -> Element? {
		guard self.count > 0 else {
			return nil
		}

		let index = Int(arc4random_uniform(UInt32(self.count)))
		return self[index]
	}

	/// : Checks if array contains at least 1 instance of the given object type
	public func containsInstanceOf<T>(object: T) -> Bool {
		for item in self {
			if type(of: item) == type(of: object) {
				return true
			}
		}
		return false
	}

	/// : Checks if test returns true for all the elements in self
	public func testAll(test: (Element) -> Bool) -> Bool {
		for item in self {
			if !test(item) {
				return false
			}
		}
		return true
	}

	/// : Checks if all elements in the array are true of false
	public func testIfAllIs(condition: Bool) -> Bool {
		for item in self {
			guard let item = item as? Bool else { return false }

			if item != condition {
				return false
			}
		}
		return true
	}

	/// : Gets the object at the specified index, if it exists.
	public func get(index: Int) -> Element? {
		return index >= 0 && index < count ? self[index]: nil
	}

	/// : Reverse the given index. i.g.: reverseIndex(2) would be 2 to the last
	public func reverseIndex(index: Int) -> Int {
		return Swift.max(self.count - 1 - index, 0)
	}

	/// : Returns an array with the given number as the max number of elements.
	public func takeMax(n: Int) -> Array {
		return Array(self[0 ..< Swift.max(0, Swift.min(n, count))])
	}

	/// : Iterates on each element of the array.
	public func each(call: (Element) -> ()) {
		for item in self {
			call(item)
		}
	}

	/// : Iterates on each element of the array with its index.
	public func each(call: (Int, Element) -> ()) {
		for (index, item) in self.enumerated() {
			call(index, item)
		}
	}

	/// : Creates an array with values generated by running each value of self
	/// through the mapFunction and discarding nil return values.
	public func mapFilter<V>(mapFunction map: (Element) -> (V)?) -> [V] {
		var mapped = [V]()
		each { (value: Element) -> Void in
			if let mappedValue = map(value) {
				mapped.append(mappedValue)
			}
		}
		return mapped
	}

	/// : Prepends an object to the array.
	public mutating func insertAsFirst(newElement: Element) {
		insert(newElement, at: 0)
	}

	/// : Shuffles the array in-place using the Fisher-Yates-Durstenfeld algorithm.
	public mutating func shuffle() {
		var j: Int

		for i in 0 ..< (self.count - 2) {
			j = Int(arc4random_uniform(UInt32(self.count - i)))
			if i != i + j { swap(&self[i], &self[i + j]) }
		}
	}
}

extension Array where Element: Equatable {

	/// : Returns the indexes of the object
	public func indexesOf(object: Element) -> [Int] {
		var indexes = [Int]()
		for index in 0 ..< self.count {
			if self[index] == object {
				indexes.append(index)
			}
		}
		return indexes
	}

	/// : Returns the last index of the object
	public func lastIndexOf(object: Element) -> Int? {
		return indexesOf(object: object).last
	}

	/// : Checks if self contains a list of items.
	public func contains(items: Element ...) -> Bool {
		return items.testAll { self.index(of: $0)! >= 0 }
	}

	/// : Difference of self and the input arrays.
	public func difference(values: [Element] ...) -> [Element] {
		var result = [Element]()
		elements: for element in self {
			for value in values {
				// if a value is in both self and one of the values arrays
				// jump to the next iteration of the outer loop
				if value.contains(element) {
					continue elements
				}
			}
			// element it's only in self
			result.append(element)
		}
		return result
	}

	/// : Intersection of self and the input arrays.
	public func intersection(values: [Element] ...) -> Array {
		var result = self
		var intersection = Array()

		for (i, value) in values.enumerated() {
			// the intersection is computed by intersecting a couple per loop:
			// self n values[0], (self n values[0]) n values[1], ...
			if i > 0 {
				result = intersection
				intersection = Array()
			}

			// find common elements and save them in first set
			// to intersect in the next loop
			value.each { (item: Element) -> Void in
				if result.contains(item) {
					intersection.append(item)
				}
			}
		}
		return intersection
	}

	/// : Union of self and the input arrays.
	public func union(values: [Element] ...) -> Array {
		var result = self
		for array in values {
			for value in array {
				if !result.contains(value) {
					result.append(value)
				}
			}
		}
		return result
	}

	/// : Removes the first given object
	public mutating func removeObject(object: Element) {
		if let index = self.index(of: object) {
			self.remove(at: index)
		}
	}

	/// : Removes all occurrences of the given object
	public mutating func removeObjects(object: Element) {
		for i in self.indexesOf(object: object).reversed() {
			self.remove(at: i)
		}
	}

	/// : Checks if the main array contains the parameter array
	public func containsArray(lookFor: [Element]) -> Bool {
		for item in lookFor {
			if self.contains(item) == false {
				return false
			}
		}
		return true
	}
}

public func == <T: Equatable>(lhs: [T]?, rhs: [T]?) -> Bool {
	switch (lhs, rhs) {
	case (.some(let lhs), .some(let rhs)):
		return lhs == rhs
	case (.none, .none):
		return true
	default:
		return false
	}
}

extension Dictionary {
	/// : Returns a random element inside Dictionary
	public func random() -> Value {
		let index: Int = Int(arc4random_uniform(UInt32(self.count)))
		return Array(self.values)[index]
	}

	/// : Union of self and the input dictionaries.
	public func union(dictionaries: Dictionary ...) -> Dictionary {
		var result = self
		dictionaries.forEach { (dictionary) -> Void in
			dictionary.forEach { (key, value) -> Void in
				_ = result.updateValue(value, forKey: key)
			}
		}
		return result
	}

	/// : Intersection of self and the input dictionaries.
	/// Two dictionaries are considered equal if they contain the same [key: value] copules.
	public func intersection<K, V>(dictionaries: [K: V] ...) -> [K: V] where K: Equatable, V: Equatable {
		// Casts self from [Key: Value] to [K: V]
		let filtered = mapFilter { (item, value) -> (K, V)? in
			if let item = item as? K,
				let value = value as? V {
					return (item, value)
			}
			return nil
		}

		// Intersection
		return filtered.filter { (key: K, value: V) -> Bool in
			// check for [key: value] in all the dictionaries
			dictionaries.testAll { $0.has(key: key) && $0[key] == value }
		}
	}

	/// : Checks if a key exists in the dictionary.
	public func has(key: Key) -> Bool {
		return index(forKey: key) != nil
	}

	/// : Creates an Array with values generated by running
	/// each [key: value] of self through the mapFunction.
	public func toArray<V>(map: (Key, Value) -> V) -> [V] {
		var mapped: [V] = []
		forEach {
			mapped.append(map($0, $1))
		}
		return mapped
	}

	/// : Creates a Dictionary with the same keys as self and values generated by running
	/// each [key: value] of self through the mapFunction.
	public func mapValues<V>(map: (Key, Value) -> V) -> [Key: V] {
		var mapped: [Key: V] = [:]
		forEach {
			mapped[$0] = map($0, $1)
		}
		return mapped
	}

	/// : Creates a Dictionary with the same keys as self and values generated by running
	/// each [key: value] of self through the mapFunction discarding nil return values.
	public func mapFilterValues<V>(map: (Key, Value) -> V?) -> [Key: V] {
		var mapped: [Key: V] = [:]
		forEach {
			if let value = map($0, $1) {
				mapped[$0] = value
			}
		}
		return mapped
	}

	/// : Creates a Dictionary with keys and values generated by running
	/// each [key: value] of self through the mapFunction discarding nil return values.
	public func mapFilter<K, V>(map: (Key, Value) -> (K, V)?) -> [K: V] {
		var mapped: [K: V] = [:]
		forEach {
			if let value = map($0, $1) {
				mapped[value.0] = value.1
			}
		}
		return mapped
	}

	/// : Creates a Dictionary with keys and values generated by running
	/// each [key: value] of self through the mapFunction.
	public func map<K, V>(map: (Key, Value) -> (K, V)) -> [K: V] {
		var mapped: [K: V] = [:]
		forEach {
			let (_key, _value) = map($0, $1)
			mapped[_key] = _value
		}
		return mapped
	}

	/// : Constructs a dictionary containing every [key: value] pair from self
	/// for which testFunction evaluates to true.
	public func filter(test: (Key, Value) -> Bool) -> Dictionary {
		var result = Dictionary()
		for (key, value) in self {
			if test(key, value) {
				result[key] = value
			}
		}
		return result
	}

	/// : Checks if test evaluates true for all the elements in self.
	public func testAll(test: (Key, Value) -> (Bool)) -> Bool {
		for (key, value) in self {
			if !test(key, value) {
				return false
			}
		}
		return true
	}
}

extension Dictionary where Value: Equatable {
	/// : Difference of self and the input dictionaries.
	/// Two dictionaries are considered equal if they contain the same [key: value] pairs.
	public func difference(dictionaries: [Key: Value] ...) -> [Key: Value] {
		var result = self
		for dictionary in dictionaries {
			for (key, value) in dictionary {
				if result.has(key: key) && result[key] == value {
					result.removeValue(forKey: key)
				}
			}
		}
		return result
	}
}

/// : Combines the first dictionary with the second and returns single dictionary
public func += <KeyType, ValueType> (left: inout Dictionary<KeyType, ValueType>, right: Dictionary<KeyType, ValueType>) {
	for (k, v) in right {
		left.updateValue(v, forKey: k)
	}
}

/// : Difference operator
public func - <K, V: Equatable> (first: [K: V], second: [K: V]) -> [K: V] {
	return first.difference(dictionaries: second)
}

/// : Intersection operator
public func & <K, V: Equatable> (first: [K: V], second: [K: V]) -> [K: V] {
	return first.intersection(dictionaries: second)
}

/// : Union operator
public func | <K: Hashable, V> (first: [K: V], second: [K: V]) -> [K: V] {
	return first.union(dictionaries: second)
}

extension Int {

	public func factorial() -> Int {
		var sum = 1
		if self == 0 {
			return sum
		}
		for i in 1...self {
			sum *= i
		}
		return sum
	}
	/// : Checks if the integer is even.
	public var isEven: Bool { return (self % 2 == 0) }

	/// : Checks if the integer is odd.
	public var isOdd: Bool { return (self % 2 != 0) }

	/// : Checks if the integer is positive.
	public var isPositive: Bool { return (self > 0) }

	/// : Checks if the integer is negative.
	public var isNegative: Bool { return (self < 0) }

	/// : Converts integer value to Double.
	public var toDouble: Double { return Double(self) }

	/// : Converts integer value to Float.
	public var toFloat: Float { return Float(self) }

	/// : Converts integer value to CGFloat.
	public var toCGFloat: CGFloat { return CGFloat(self) }

	/// : Converts integer value to String.
	public var toString: String { return String(self) }

	/// : Converts integer value to UInt.
	public var toUInt: UInt { return UInt(self) }

	/// : Converts integer value to a 0..<Int range. Useful in for loops.
	public var range: Range<Int> { return 0 ..< self }

	/// : Returns number of digits in the integer.
	public var digits: Int {
		if self == 0 {
			return 1
		} else if Int(fabs(Double(self))) <= LONG_MAX {
			return Int(log10(fabs(Double(self)))) + 1
		} else {
			return -1; // out of bound
		}
	}
}

extension UInt {
	/// : Convert UInt to Int
	public var toInt: Int { return Int(self) }
}

extension Bool {
	/// : Converts Bool to Int.
	public var toInt: Int {
		return self == true ? 1 : 0

	}

	/// : Toggle boolean value.
	public mutating func toggle() -> Bool {
		self = !self
		return self
	}
}

extension CGFloat {
	/// : Return the central value of CGFloat.
	public var center: CGFloat { return (self / 2) }

	public func toRadians() -> CGFloat {
		return (CGFloat(M_PI) * self) / 180.0
	}

	public func degreesToRadians() -> CGFloat {
		return toRadians()
	}

	public mutating func toRadiansInPlace() {
		self = (CGFloat(M_PI) * self) / 180.0
	}

	/// : Converts angle degrees to radians.
	public func degreesToRadians(angle: CGFloat) -> CGFloat {
		return (CGFloat(M_PI) * angle) / 180.0
	}
}

extension Double {
	/// : Converts Double to String
	public var toString: String { return String(self) }
	/// : Converts Double to Int
	public var toInt: Int { return Int(self) }

}

extension Character {
	/// : Converts Character to String //TODO: Add to readme
	public var toString: String { return String(self) }

	/// : If the character represents an integer that fits into an Int, returns the corresponding integer.
	/// TODO: Add to readme
	public var toInt: Int? { return Int(String(self)) }
}

extension CGRect {
	/// : Easier initialization of CGRect
	public init(x: CGFloat, y: CGFloat, w: CGFloat, h: CGFloat) {
		self.init(x: x, y: y, width: w, height: h)
	}

	/// : X value of CGRect's origin
	public var x: CGFloat {
		get {
			return self.origin.x
		} set(value) {
			self.origin.x = value
		}
	}

	/// : Y value of CGRect's origin
	public var y: CGFloat {
		get {
			return self.origin.y
		} set(value) {
			self.origin.y = value
		}
	}

	/// : Width of CGRect's size
	public var w: CGFloat {
		get {
			return self.size.width
		} set(value) {
			self.size.width = value
		}
	}

	/// : Height of CGRect's size
	public var h: CGFloat {
		get {
			return self.size.height
		} set(value) {
			self.size.height = value
		}
	}
}

extension String {

	/// : Character count
	public var length: Int {
		return self.characters.count
	}

	/// : Checks if String contains Email
	public var isEmail: Bool {
		let dataDetector = try? NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue)
		let firstMatch = dataDetector?.firstMatch(in: self, options: NSRegularExpression.MatchingOptions.reportCompletion, range: NSRange(location: 0, length: length))
		return (firstMatch?.range.location != NSNotFound && firstMatch?.url?.scheme == "mailto")
	}

	/// : Returns if String is a number
	public func isNumber() -> Bool {
		if let _ = NumberFormatter().number(from: self) {
			return true
		}
		return false
	}

	/// : Extracts URLS from String
	public var extractURLs: [NSURL] {
		var urls: [NSURL] = []
		let detector: NSDataDetector?
		do {
			detector = try NSDataDetector(types: NSTextCheckingResult.CheckingType.link.rawValue)
		} catch _ as NSError {
			detector = nil
		}

		let text = self

		if let detector = detector {
			detector.enumerateMatches(in: text, options: [], range: NSRange(location: 0, length: text.characters.count), using: {
				(result: NSTextCheckingResult?, flags: NSRegularExpression.MatchingFlags, stop: UnsafeMutablePointer<ObjCBool>) -> Void in
				if let result = result,
					let url = result.url {
						urls.append(url as NSURL)
				}
			})
		}

		return urls
	}

	/// : Converts String to Int
	public func toInt() -> Int? {
		if let num = NumberFormatter().number(from: self) {
			return num.intValue
		} else {
			return nil
		}
	}

	/// : Converts String to Double
	public func toDouble() -> Double? {
		if let num = NumberFormatter().number(from: self) {
			return num.doubleValue
		} else {
			return nil
		}
	}

	/// : Converts String to Float
	public func toFloat() -> Float? {
		if let num = NumberFormatter().number(from: self) {
			return num.floatValue
		} else {
			return nil
		}
	}

	/// : Returns the first index of the occurency of the character in String
	public func getIndexOf(char: Character) -> Int? {
		for (index, c) in characters.enumerated() {
			if c == char {
				return index
			}
		}
		return nil
	}

	/// : Converts String to NSString
	public var toNSString: NSString { get { return self as NSString } }

	/// : Returns bold NSAttributedString
	public func bold() -> NSAttributedString {
		let boldString = NSMutableAttributedString(string: self, attributes: [NSFontAttributeName: UIFont.boldSystemFont(ofSize: UIFont.systemFontSize)])
		return boldString
	}

	/// : Returns underlined NSAttributedString
	public func underline() -> NSAttributedString {
		let underlineString = NSAttributedString(string: self, attributes: [NSUnderlineStyleAttributeName: NSUnderlineStyle.styleSingle.rawValue])
		return underlineString
	}

	/// : Returns italic NSAttributedString
	public func italic() -> NSAttributedString {
		let italicString = NSMutableAttributedString(string: self, attributes: [NSFontAttributeName: UIFont.italicSystemFont(ofSize: UIFont.systemFontSize)])
		return italicString
	}

	/// : Returns NSAttributedString
	public func color(color: UIColor) -> NSAttributedString {
		let colorString = NSMutableAttributedString(string: self, attributes: [NSForegroundColorAttributeName: color])
		return colorString
	}

	/// : Checks if String contains Emoji
	public func includesEmoji() -> Bool {
		for i in 0 ... length {
			let c: unichar = (self as NSString).character(at: i)
			if (0xD800 <= c && c <= 0xDBFF) || (0xDC00 <= c && c <= 0xDFFF) {
				return true
			}
		}
		return false
	}
}

extension NSString {
	public func calculateSize(size: CGSize, attributes: [String: AnyObject]) -> CGSize {
		return self.boundingRect(with: CGSize(width: CGFloat.greatestFiniteMagnitude, height: 30), options: [], attributes: attributes, context: NSStringDrawingContext()).size
	}

	public func getWidth(maxHeight: CGFloat, attributes: [String: AnyObject]) -> CGFloat {
		return self.calculateSize(size: CGSize(width: CGFloat.greatestFiniteMagnitude, height: maxHeight), attributes: attributes).width
	}

	public func getHeight(maxWidth: CGFloat, attributes: [String: AnyObject]) -> CGFloat {
		return self.calculateSize(size: CGSize(width: maxWidth, height: CGFloat.greatestFiniteMagnitude), attributes: attributes).width
	}
}

extension NSAttributedString {
	public func calculateSize(size: CGSize) -> CGSize {
		let rect = self.boundingRect(with: size, options: [.usesLineFragmentOrigin, .usesFontLeading], context: NSStringDrawingContext())
		return rect.size
	}

	public func getWidth(maxHeight: CGFloat) -> CGFloat {
		return self.calculateSize(size: CGSize(width: CGFloat.greatestFiniteMagnitude, height: maxHeight)).width
	}

	public func getHeight(maxWidth: CGFloat) -> CGFloat {
		return self.calculateSize(size: CGSize(width: maxWidth, height: CGFloat.greatestFiniteMagnitude)).height + 2
	}
}

extension Date {

	public func toFormatDateString(format: String) -> String {
		// return self.toFormatDateString(format: format)
		return self.string(custom: format)
	}

}
